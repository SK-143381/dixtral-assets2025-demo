<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DIXTRAL: An Interactive Report</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="src/styles/main.css">
    <!-- Chosen Palette: Academic Calm -->
    <!-- Application Structure Plan: A single-page, long-scroll layout with a sticky navigation header. This structure guides the user through a narrative: starting with the core problem, introducing the DIXTRAL system through an interactive simulation of its multimodal feedback, explaining its technical architecture, and concluding with the key research findings. This thematic flow is more engaging for a web audience than a linear paper format, allowing users to both get a quick overview and dive into specific sections. The interactive simulation is the centerpiece, designed to give a tangible feel for the user experience without needing a full WebGL implementation. -->
    <!-- Visualization & Content Choices: The application visualizes concepts rather than raw data. The central 'DIXTRAL in Action' section uses an interactive mock-up (HTML/CSS buttons and text areas) to simulate the system's core feedback loop (Goal: Demonstrate multimodal interaction). An interactive diagram built with HTML/CSS is used to explain the 5-layer system architecture (Goal: Organize complex information). Key findings are presented as digestible cards (Goal: Inform). This approach uses interaction to clarify the paper's concepts, adhering to the NO SVG/Mermaid constraint. All interactions are powered by vanilla JavaScript. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f9fa;
            color: #212529;
        }
        .accent-color { color: #005f73; }
        .accent-bg { background-color: #005f73; }
        .accent-border { border-color: #005f73; }
        .secondary-bg { background-color: #e9ecef; }
        
        /* Remove all header-related styles */
        
        /* Ensure all sections have proper spacing */
        #challenge, #simulation, #architecture, #findings {
            margin-bottom: 5rem;
        }
        
        /* Fix z-index for demo section to ensure buttons are clickable */
        #simulation {
            position: relative;
            z-index: 10;
        }
        
        /* Ensure navigation buttons are accessible */
        #simulation .bg-white {
            position: relative;
            z-index: 20;
        }
        .highlight-active {
            transition: all 0.3s ease-in-out;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0, 95, 115, 0.5);
        }
        
        /* Demo canvas styling */
        #demoCanvas {
            width: 100%;
            height: 400px;
            min-height: 300px;
            border: 1px solid #e5e7eb;
            background-color: #1a1a1a;
            display: block;
        }
        
        /* Enhance virtual button styling for better interaction */
        .virtual-nav-btn {
            min-height: 48px;
            min-width: 48px;
            transition: all 0.2s ease;
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            position: relative;
            z-index: 1000;
            border: 2px solid transparent;
            display: inline-block;
        }
        
        .virtual-nav-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 95, 115, 0.2);
            border-color: #005f73;
        }
        
        .virtual-nav-btn:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 95, 115, 0.3);
            background-color: #005f73 !important;
            color: white !important;
        }
        
        .virtual-nav-btn:focus {
            outline: 2px solid #005f73;
            outline-offset: 2px;
        }
        
        /* Prevent text selection on the entire demo section */
        #simulation * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        /* Allow text selection only in text output area */
        #text-output {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }
        
        /* Hidden state for mode-specific controls */
        .point-mode-only {
            display: none;
        }
    </style>
</head>
<body class="antialiased">

    <main class="container mx-auto px-6 py-12">
        <!-- Hero Section -->
        <section id="hero" class="text-center mb-16">
            <h1 class="text-4xl md:text-5xl font-bold mb-4">Mobile Compatible DIXTRAL</h1>
            <p class="text-lg md:text-xl text-gray-700 max-w-3xl mx-auto mb-4">An interactive overview of DIXTRAL, a system for multimodal interaction with 3D data visualizations for blind and low-vision users.</p>
            <p class="text-sm text-gray-500 mb-6">Based on the paper by Sanchita S. Kamath, Aziz Zeidieh, & JooYoung Seo</p>
            
            <!-- Quick Links -->
            <div class="flex flex-wrap justify-center gap-4 mb-8">
                <a href="https://sanchitakamath.com/dixtral-assets2025-demo/" target="_blank" rel="noopener" class="px-6 py-3 accent-bg text-white rounded-lg hover:bg-opacity-90 transition font-semibold">Live Demo</a>
                <a href="https://github.com/SK-143381/dixtral-assets2025-demo" target="_blank" rel="noopener" class="px-6 py-3 border-2 accent-border accent-color rounded-lg hover:accent-bg hover:text-white transition font-semibold">Source Code</a>
                <a href="https://arxiv.org/pdf/2508.08554v1" target="_blank" rel="noopener" class="px-6 py-3 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition font-semibold">Read the Paper</a>
            </div>
        </section>

        <!-- The Challenge Section -->
        <section id="challenge" class="mb-12">
            <h2 class="text-2xl font-bold text-center mb-6">The Challenge of Inaccessible Data</h2>
            <div class="max-w-4xl mx-auto bg-white p-6 rounded-lg shadow-md">
                <p class="text-base text-gray-800 mb-4">Three-dimensional data visualizations are invaluable in science and engineering, revealing complex spatial patterns. However, their reliance on visual interaction excludes blind and low-vision (BLV) users, creating a significant barrier to STEM fields.</p>
                <blockquote class="border-l-4 accent-border pl-4 italic text-gray-600 text-sm">
                    "Existing alternatives like alt-text or static 3D prints often increase cognitive load, lack interactivity, and fail to convey the dynamic nature of 3D data. Our research addresses this gap by creating a web-native, multimodal system from the ground up."
                </blockquote>
            </div>
        </section>
        
        <!-- Interactive Simulation Section -->
        <section id="simulation" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-4">DIXTRAL in Action</h2>
            <p class="text-center text-gray-600 mb-8 max-w-3xl mx-auto">Experience DIXTRAL's full functionality with this interactive benzene point plot. Use the virtual controls below to navigate the 3D data and experience synchronized multimodal feedback.</p>
            
            <div class="bg-white p-6 md:p-8 rounded-lg shadow-xl grid md:grid-cols-2 gap-8">
                <!-- Left: Real 3D Plot & Controls -->
                <div class="flex flex-col">
                    <h3 class="font-bold text-xl mb-4">Benzene 3D Point Plot & Controls</h3>
                    <canvas id="demoCanvas" 
                            style="width: 100%; height: 400px; background-color: #1a1a1a; border: 1px solid #e5e7eb;"
                            tabindex="0"
                            aria-label="Interactive 3D benzene point plot - Use virtual controls below to navigate">
                    </canvas>
                    
                    <div class="grid grid-cols-3 gap-2 items-center justify-center">
                        <div></div>
                        <button id="nav-up" class="virtual-nav-btn p-3 bg-gray-200 hover:accent-bg hover:text-white rounded transition" aria-label="Navigate up">↑</button>
                        <div></div>
                        <button id="nav-left" class="virtual-nav-btn p-3 bg-gray-200 hover:accent-bg hover:text-white rounded transition" aria-label="Navigate left">←</button>
                        <div class="text-center font-medium text-gray-700">Navigate</div>
                        <button id="nav-right" class="virtual-nav-btn p-3 bg-gray-200 hover:accent-bg hover:text-white rounded transition" aria-label="Navigate right">→</button>
                        <div></div>
                        <button id="nav-down" class="virtual-nav-btn p-3 bg-gray-200 hover:accent-bg hover:text-white rounded transition" aria-label="Navigate down">↓</button>
                        <div></div>
                    </div>
                    
                    <!-- Segment Navigation (Point Mode Only) -->
                    <div id="y-segment-controls" class="grid grid-cols-2 gap-4 mt-6 point-mode-only">
                        <button id="prev-segment" class="virtual-nav-btn w-full p-3 bg-blue-200 hover:bg-blue-600 hover:text-white rounded transition" aria-label="Move to previous segment">← Prev Segment</button>
                        <button id="next-segment" class="virtual-nav-btn w-full p-3 bg-blue-200 hover:bg-blue-600 hover:text-white rounded transition" aria-label="Move to next segment">Next Segment →</button>
                    </div>
                    
                     <div class="grid grid-cols-2 gap-4 mt-6">
                        <button id="switch-axis" class="virtual-nav-btn w-full p-3 bg-gray-200 hover:accent-bg hover:text-white rounded transition" aria-label="Switch navigation axis">Switch Axis (N)</button>
                        <button id="autoplay" class="virtual-nav-btn w-full p-3 bg-gray-200 hover:accent-bg hover:text-white rounded transition" aria-label="Toggle autoplay">Autoplay (P)</button>
                    </div>
                    <div class="grid grid-cols-2 gap-4 mt-4">
                        <button id="toggle-sonification" class="virtual-nav-btn w-full p-3 bg-gray-200 hover:accent-bg hover:text-white rounded transition" aria-label="Toggle audio sonification">Audio (S)</button>
                        <button id="switch-mode" class="virtual-nav-btn w-full p-3 bg-gray-200 hover:accent-bg hover:text-white rounded transition" aria-label="Switch between surface and point mode">Point Mode</button>
                    </div>

                </div>

                <!-- Right: Feedback Panels -->
                <div>
                    <h3 class="font-bold text-xl mb-4">Live Feedback</h3>
                    
                    <!-- Textual Output -->
                    <div class="mb-6">
                        <label for="text-output" class="font-semibold text-gray-700 block mb-2">Textual & Spoken Output</label>
                        <div id="text-output" class="w-full h-24 p-3 secondary-bg rounded-md font-mono text-sm text-gray-800 overflow-y-auto">
                            Manual Navigation (Y-Axis): Navigating Z-Axis. Point(2.1, 7.8, 4.1), Duration: Long
                        </div>
                    </div>

                    <!-- Sonification Mapping -->
                    <div>
                        <h4 class="font-semibold text-gray-700 mb-2">Sonification Mapping</h4>
                        <div class="space-y-2">
                            <div id="map-y" class="p-3 secondary-bg rounded-md transition duration-300">
                                <span class="font-bold accent-color">Y-Value</span> → Mapped to Audio <span class="font-bold">Pitch</span> (High/Low)
                            </div>
                            <div id="map-x" class="p-3 secondary-bg rounded-md transition duration-300">
                                <span class="font-bold accent-color">X-Value</span> → Mapped to Audio <span class="font-bold">Stereo Pan</span> (Left/Right)
                            </div>
                            <div id="map-z" class="p-3 secondary-bg rounded-md transition duration-300">
                               <span class="font-bold accent-color">Z-Value</span> → Mapped to Audio <span class="font-bold">Duration & Volume</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Architecture Section -->
        <section id="architecture" class="mb-20">
            <h2 class="text-3xl font-bold text-center mb-4">System Architecture</h2>
            <p class="text-center text-gray-600 mb-8 max-w-3xl mx-auto">DIXTRAL is built on a modular, five-layer architecture. This separation of concerns ensures that accessibility is a core, independent component, not an afterthought. Click on a layer to learn more.</p>
            <div class="flex flex-col md:flex-row gap-8">
                <div class="w-full md:w-1/2 flex flex-col gap-2">
                    <div id="layer-app" class="layer-btn p-4 border-2 border-gray-300 rounded-md cursor-pointer hover:accent-border hover:bg-teal-50 transition">
                        <h4 class="font-bold">Application Layer</h4>
                        <p class="text-sm">Global coordination & lifecycle.</p>
                    </div>
                    <div id="layer-ui" class="layer-btn p-4 border-2 border-gray-300 rounded-md cursor-pointer hover:accent-border hover:bg-teal-50 transition">
                        <h4 class="font-bold">UI Layer</h4>
                        <p class="text-sm">Manages all visual components and controls.</p>
                    </div>
                     <div id="layer-access" class="layer-btn p-4 border-2 border-gray-300 rounded-md cursor-pointer hover:accent-border hover:bg-teal-50 transition">
                        <h4 class="font-bold">Accessibility Layer</h4>
                        <p class="text-sm">Centralizes all non-visual access features.</p>
                    </div>
                    <div id="layer-engine" class="layer-btn p-4 border-2 border-gray-300 rounded-md cursor-pointer hover:accent-border hover:bg-teal-50 transition">
                        <h4 class="font-bold">Engine Layer</h4>
                        <p class="text-sm">The WebGL rendering pipeline for visualization.</p>
                    </div>
                    <div id="layer-data" class="layer-btn p-4 border-2 border-gray-300 rounded-md cursor-pointer hover:accent-border hover:bg-teal-50 transition">
                        <h4 class="font-bold">Data Layer</h4>
                        <p class="text-sm">Handles data ingestion, generation, and analysis.</p>
                    </div>
                </div>
                <div class="w-full md:w-1/2 bg-white p-6 rounded-lg shadow-md min-h-[200px]">
                    <h3 id="layer-title" class="font-bold text-xl accent-color mb-2">Select a Layer</h3>
                    <p id="layer-desc" class="text-gray-700">Click on one of the layers to the left to see its description and core responsibilities within the DIXTRAL system.</p>
                </div>
            </div>
        </section>

        <!-- Findings Section -->
        <section id="findings" class="mb-12">
            <h2 class="text-3xl font-bold text-center mb-8">Key Research Findings</h2>
            <div class="grid md:grid-cols-3 gap-8">
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h3 class="font-bold text-lg mb-2 accent-color">Multimodal Interaction is Key</h3>
                    <p class="text-gray-700">Synchronizing sonification, textual feedback, and visual highlights enables users to form a more complete mental model of the data, leveraging different perceptual strengths.</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h3 class="font-bold text-lg mb-2 accent-color">Dual Exploration Strategy</h3>
                    <p class="text-gray-700">Combining a high-level "whole-to-part" overview (Autoplay) with detailed "part-to-whole" inspection (Manual Navigation) is critical for orientation and deep analysis.</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h3 class="font-bold text-lg mb-2 accent-color">Accessibility Benefits All</h3>
                    <p class="text-gray-700">An accessibility-first design with features like gamepad control and clear feedback can create a more robust and usable interface for both BLV and sighted users.</p>
                </div>
            </div>
        </section>
    </main>

    <!-- Hidden elements required by DIXTRAL application -->
    <div style="display: none;" aria-hidden="true">
        <!-- UI Control elements that DIXTRAL expects -->
        <input type="range" id="xStart" min="120" max="200" value="120">
        <input type="range" id="xEnd" min="120" max="200" value="200">
        <input type="range" id="zStart" min="0" max="15" value="0">
        <input type="range" id="zEnd" min="0" max="15" value="15">
        <select id="displayMode">
            <option value="points" selected>Points</option>
            <option value="surface">Surface</option>
        </select>
        <select id="colorScheme">
            <option value="rainbow">Rainbow</option>
        </select>
        <input type="range" id="pointSize" min="1" max="10" value="3">
        <input type="range" id="threshold" min="0" max="1" value="0">
        <input type="range" id="rotationX" min="-180" max="180" value="0">
        <input type="range" id="rotationY" min="-180" max="180" value="0">
        <input type="range" id="zoom" min="0.1" max="2" value="1">
        
        <!-- Value display elements that UI controller updates -->
        <span id="xStartValue">120</span>
        <span id="xEndValue">200</span>
        <span id="zStartValue">0.0</span>
        <span id="zEndValue">15.0</span>
        <span id="pointSizeValue">3</span>
        <span id="thresholdValue">0.00</span>
        <span id="rotationXValue">0°</span>
        <span id="rotationYValue">0°</span>
        <span id="zoomValue">1.0x</span>
        <span id="fps">0</span>
        <span id="pointCount">0</span>
        
        <!-- Sample info display element -->
        <div id="sampleInfo"></div>
        
        <!-- Navigation info display element -->
        <div id="navigationInfo"></div>
        
        <!-- Screen reader elements -->
        <div id="screen-reader-announcement" aria-live="polite"></div>
        <div id="navigation-announcements" aria-live="assertive"></div>
    </div>

    <!-- Footer -->
    <footer class="secondary-bg border-t border-gray-200">
        <div class="max-w-4xl mx-auto text-center">
            <p class="font-bold text-lg mb-2 accent-color">DIXTRAL</p>
            <p class="mb-4">This interactive report is based on the research paper "Mobile Compatible DIXTRAL" from the University of Illinois Urbana-Champaign.</p>
        </div>
    </footer>

<script type="module">
// Import the DIXTRAL application
import { SurfacePlotApplication } from './src/app.js';

document.addEventListener('DOMContentLoaded', async () => {
    // --- Initialize DIXTRAL Application ---
    const demoApp = new SurfacePlotApplication();
    
    // Initialize with the demo canvas
    const canvas = document.getElementById('demoCanvas');
    if (canvas) {
        try {
            // Set proper canvas dimensions
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width || 800;
            canvas.height = rect.height || 400;
            
            // Ensure WebGL context can be created
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) {
                throw new Error('WebGL not supported');
            }
            
            // Clear the canvas to a dark color initially
            gl.clearColor(0.1, 0.1, 0.1, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            await demoApp.initialize(canvas);
            
            // Load benzene data in point mode
            await new Promise(resolve => {
                setTimeout(() => {
                    demoApp.data.loadSample('benzene');
                    resolve();
                }, 100);
            });
            
            // Set to point display mode after a short delay
            setTimeout(() => {
                const displayModeEvent = new CustomEvent('display-mode-changed', {
                    detail: { displayMode: 'points' }
                });
                document.dispatchEvent(displayModeEvent);
                
                // Force a render after everything is set up
                if (demoApp.engine) {
                    demoApp.engine.render(demoApp.data);
                }
                
                // Activate navigation system and focus canvas
                if (demoApp.navigation) {
                    demoApp.navigation.isActive = true;
                    canvas.focus();
                    
                    // Set initial text output
                    setTimeout(() => {
                        const navInfo = getCurrentNavigationInfo();
                        if (navInfo) {
                            updateTextOutput(navInfo);
                        } else {
                            updateTextOutput('DIXTRAL navigation active. Use virtual controls to explore the benzene point cloud.');
                        }
                    }, 100);
                }
            }, 500);
            
        } catch (error) {
            console.error('Failed to initialize demo application:', error);
            
            // Show error in the canvas area
            const parent = canvas.parentNode;
            const errorDiv = document.createElement('div');
            errorDiv.className = 'w-full aspect-video bg-red-100 rounded-md flex items-center justify-center';
            errorDiv.innerHTML = `
                <div class="text-center p-4">
                    <p class="text-red-700 font-bold">Failed to initialize 3D plot</p>
                    <p class="text-red-600 text-sm">WebGL may not be supported in your browser</p>
                </div>
            `;
            parent.replaceChild(errorDiv, canvas);
        }
    }

    // --- Virtual Controls Implementation ---
    const textOutput = document.getElementById('text-output');
    const navButtons = {
        up: document.getElementById('nav-up'),
        down: document.getElementById('nav-down'),
        left: document.getElementById('nav-left'),
        right: document.getElementById('nav-right'),
    };
    const switchAxisBtn = document.getElementById('switch-axis');
    const autoplayBtn = document.getElementById('autoplay');
    const sonificationBtn = document.getElementById('toggle-sonification');
    const switchModeBtn = document.getElementById('switch-mode');
    const nextSegmentBtn = document.getElementById('next-segment');
    const prevSegmentBtn = document.getElementById('prev-segment');
    const ySegmentControls = document.getElementById('y-segment-controls');
    
    const sonificationMaps = {
        x: document.getElementById('map-x'),
        y: document.getElementById('map-y'),
        z: document.getElementById('map-z'),
    };

    // Virtual key mappings to actual DIXTRAL functionality
    function simulateKeyPress(key) {
        if (!canvas) return;
        
        // Try direct access first, then fall back to keyboard events
        if (demoApp && demoApp.navigation) {
            try {
                if (key === 'n' && demoApp.navigation.toggleNavigationAxis) {
                    demoApp.navigation.toggleNavigationAxis();
                    return;
                } else if (key === 'p' && demoApp.navigation.handlePKeyPress) {
                    demoApp.navigation.handlePKeyPress();
                    return;
                } else if (key === 's' && demoApp.navigation.sonificationController) {
                    demoApp.navigation.sonificationController.toggleEnabled();
                    return;
                } else if (key === 'v' && demoApp.navigation.reviewModeController) {
                    demoApp.navigation.reviewModeController.toggleReviewMode();
                    return;
                }
            } catch (error) {
                console.log('Direct access failed, using keyboard events');
            }
        }
        
        // Fallback to keyboard event simulation
        const event = new KeyboardEvent('keydown', {
            key: key,
            code: `Key${key.toUpperCase()}`,
            keyCode: key.charCodeAt(0),
            which: key.charCodeAt(0),
            bubbles: true,
            cancelable: true
        });
        canvas.dispatchEvent(event);
    }

    // Track current display mode
    let currentDisplayMode = 'points'; // Start with points mode

    function switchDisplayMode() {
        // Toggle the current mode
        currentDisplayMode = (currentDisplayMode === 'points') ? 'surface' : 'points';
        
        try {
            // Method 1: Try to access the display mode control directly
            if (demoApp && demoApp.ui && demoApp.ui.controls && demoApp.ui.controls.displayMode) {
                const oldValue = demoApp.ui.controls.displayMode.value;
                demoApp.ui.controls.displayMode.value = currentDisplayMode;
                
                // Trigger the change event manually
                const changeEvent = new Event('change', { bubbles: true });
                demoApp.ui.controls.displayMode.dispatchEvent(changeEvent);
                
                console.log(`Mode switched from ${oldValue} to ${currentDisplayMode}`);
                return currentDisplayMode;
            }
            
            // Method 2: Try to find the displayMode select element in the DOM
            const displayModeSelect = document.getElementById('displayMode');
            if (displayModeSelect) {
                const oldValue = displayModeSelect.value;
                displayModeSelect.value = currentDisplayMode;
                
                // Trigger change event
                const changeEvent = new Event('change', { bubbles: true });
                displayModeSelect.dispatchEvent(changeEvent);
                
                console.log(`Mode switched via DOM from ${oldValue} to ${currentDisplayMode}`);
                console.log(`displayMode select value is now: ${displayModeSelect.value}`);
                return currentDisplayMode;
            } else {
                console.log('displayMode select not found in DOM');
            }
            
            // Method 3: Try direct method calls on the app
            if (demoApp) {
                if (currentDisplayMode === 'surface' && demoApp.switchToSurface) {
                    demoApp.switchToSurface();
                    return currentDisplayMode;
                } else if (currentDisplayMode === 'points' && demoApp.switchToPoints) {
                    demoApp.switchToPoints();
                    return currentDisplayMode;
                }
            }
            
            console.log('No mode switching method found, mode may not have changed');
            return currentDisplayMode;
            
        } catch (error) {
            console.error('Error during mode switch:', error);
            return currentDisplayMode;
        }
    }

    function moveToNextSegment() {
        if (!canvas) return;
        
        // Simulate Ctrl+Shift+ArrowUp for next Y segment
        const event = new KeyboardEvent('keydown', {
            key: 'ArrowUp',
            code: 'ArrowUp',
            ctrlKey: true,
            shiftKey: true,
            bubbles: true,
            cancelable: true
        });
        canvas.dispatchEvent(event);
    }

    function moveToPrevSegment() {
        if (!canvas) return;
        
        // Simulate Ctrl+Shift+ArrowDown for previous Y segment
        const event = new KeyboardEvent('keydown', {
            key: 'ArrowDown',
            code: 'ArrowDown',
            ctrlKey: true,
            shiftKey: true,
            bubbles: true,
            cancelable: true
        });
        canvas.dispatchEvent(event);
    }

    function simulateArrowKey(direction) {
        if (!canvas) return;
        
        // Try direct access first, then fall back to keyboard events
        if (demoApp && demoApp.navigation) {
            try {
                switch(direction) {
                    case 'up':
                        if (demoApp.navigation.moveForward) {
                            demoApp.navigation.moveForward();
                            return;
                        }
                        break;
                    case 'down':
                        if (demoApp.navigation.moveBackward) {
                            demoApp.navigation.moveBackward();
                            return;
                        }
                        break;
                    case 'left':
                        if (demoApp.navigation.moveLeft) {
                            demoApp.navigation.moveLeft();
                            return;
                        }
                        break;
                    case 'right':
                        if (demoApp.navigation.moveRight) {
                            demoApp.navigation.moveRight();
                            return;
                        }
                        break;
                }
            } catch (error) {
                console.log('Direct navigation failed, using keyboard events');
            }
        }
        
        // Fallback to keyboard event simulation
        const keyMap = {
            'up': 'ArrowUp',
            'down': 'ArrowDown', 
            'left': 'ArrowLeft',
            'right': 'ArrowRight'
        };
        
        const event = new KeyboardEvent('keydown', {
            key: keyMap[direction],
            code: keyMap[direction],
            bubbles: true,
            cancelable: true
        });
        canvas.dispatchEvent(event);
    }

    function highlightMapping(mapKey) {
        // Clear all highlights
        Object.values(sonificationMaps).forEach(el => {
            if (el) {
                el.classList.remove('highlight-active', 'accent-bg', 'text-white');
            }
        });
        
        // Highlight specific mapping
        if (mapKey && sonificationMaps[mapKey]) {
            sonificationMaps[mapKey].classList.add('highlight-active', 'accent-bg', 'text-white');
            
            // Remove highlight after 2 seconds
            setTimeout(() => {
                if (sonificationMaps[mapKey]) {
                    sonificationMaps[mapKey].classList.remove('highlight-active', 'accent-bg', 'text-white');
                }
            }, 2000);
        }
    }

    function updateTextOutput(message) {
        if (textOutput) {
            textOutput.textContent = message;
            textOutput.scrollTop = textOutput.scrollHeight;
        }
    }

    // Function to get current navigation info from DIXTRAL
    function getCurrentNavigationInfo() {
        try {
            if (demoApp && demoApp.navigation) {
                // Try multiple ways to get current position
                let currentPoint = null;
                let axis = 'Unknown';
                let mode = currentDisplayMode || 'points';
                
                // Get current position from multiple possible sources
                if (demoApp.navigation.getCurrentPoint) {
                    currentPoint = demoApp.navigation.getCurrentPoint();
                } else if (demoApp.navigation.currentPosition) {
                    currentPoint = demoApp.navigation.currentPosition;
                } else if (demoApp.navigation.position) {
                    currentPoint = demoApp.navigation.position;
                } else if (demoApp.navigation.textController && demoApp.navigation.textController.currentPoint) {
                    currentPoint = demoApp.navigation.textController.currentPoint;
                } else if (demoApp.data && demoApp.data.currentPoint) {
                    currentPoint = demoApp.data.currentPoint;
                }
                
                // Get current axis from multiple possible sources
                if (demoApp.navigation.currentAxis) {
                    axis = demoApp.navigation.currentAxis.toUpperCase();
                } else if (demoApp.navigation.axis) {
                    axis = demoApp.navigation.axis.toUpperCase();
                } else if (demoApp.navigation.navigationController && demoApp.navigation.navigationController.currentAxis) {
                    axis = demoApp.navigation.navigationController.currentAxis.toUpperCase();
                } else if (demoApp.navigation.navigationController && demoApp.navigation.navigationController.axis) {
                    axis = demoApp.navigation.navigationController.axis.toUpperCase();
                } else {
                    // Default to Y axis as that's the most common starting axis
                    axis = 'Y';
                }
                
                // Try to get actual coordinate values from the data
                if (!currentPoint && demoApp.data && demoApp.data.dataPoints) {
                    // Try to get the current index or position from navigation
                    let currentIndex = 0;
                    if (demoApp.navigation.currentIndex !== undefined) {
                        currentIndex = demoApp.navigation.currentIndex;
                    } else if (demoApp.navigation.index !== undefined) {
                        currentIndex = demoApp.navigation.index;
                    }
                    
                    if (demoApp.data.dataPoints[currentIndex]) {
                        currentPoint = demoApp.data.dataPoints[currentIndex];
                    }
                }
                
                // Build message based on available data
                if (currentPoint && typeof currentPoint === 'object') {
                    const x = currentPoint.x !== undefined ? currentPoint.x.toFixed(2) : '?';
                    const y = currentPoint.y !== undefined ? currentPoint.y.toFixed(2) : '?';
                    const z = currentPoint.z !== undefined ? currentPoint.z.toFixed(2) : '?';
                    
                    const pointType = mode === 'points' ? 'Point' : 'Square';
                    return `Manual Navigation (${axis}-Axis): ${pointType}(${x}, ${y}, ${z})`;
                } else {
                    return `Manual Navigation (${axis}-Axis): Navigating ${mode} mode`;
                }
            }
        } catch (error) {
            console.log('Could not get navigation info:', error);
        }
        return null;
    }

    // Virtual navigation buttons (up/down functionality swapped for point mode)
    navButtons.up?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        simulateArrowKey('down');
        highlightMapping('y');
        setTimeout(() => {
            const navInfo = getCurrentNavigationInfo();
            updateTextOutput(navInfo || 'Navigation: Moving up (Y-axis positive direction)');
        }, 100);
    });

    navButtons.down?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        simulateArrowKey('up');
        highlightMapping('y');
        setTimeout(() => {
            const navInfo = getCurrentNavigationInfo();
            updateTextOutput(navInfo || 'Navigation: Moving down (Y-axis negative direction)');
        }, 100);
    });

    navButtons.left?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        simulateArrowKey('left');
        highlightMapping('x');
        setTimeout(() => {
            const navInfo = getCurrentNavigationInfo();
            updateTextOutput(navInfo || 'Navigation: Moving left (X-axis negative direction)');
        }, 100);
    });

    navButtons.right?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        simulateArrowKey('right');
        highlightMapping('x');
        setTimeout(() => {
            const navInfo = getCurrentNavigationInfo();
            updateTextOutput(navInfo || 'Navigation: Moving right (X-axis positive direction)');
        }, 100);
    });

    // Switch axis button (N key)
    switchAxisBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        simulateKeyPress('n');
        updateTextOutput('Switching navigation axis (Y → Z → X → Y)');
    });

    // Autoplay button (P key)
    autoplayBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        simulateKeyPress('p');
        highlightMapping('z');
        updateTextOutput('Toggling autoplay mode - systematic data traversal');
    });

    // Sonification toggle (S key)
    sonificationBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        simulateKeyPress('s');
        highlightMapping('y');
        updateTextOutput('Toggling audio sonification feedback');
    });

    // Function to update control visibility based on mode
    function updateControlVisibility(mode) {
        if (ySegmentControls) {
            if (mode === 'points') {
                ySegmentControls.classList.remove('point-mode-only');
                ySegmentControls.style.display = 'grid';
            } else {
                ySegmentControls.classList.add('point-mode-only');
                ySegmentControls.style.display = 'none';
            }
        }
    }

    // Switch mode button (surface/point toggle)
    switchModeBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        console.log('Switch mode button clicked');
        
        const newMode = switchDisplayMode();
        if (newMode) {
            // Update button text to show current mode
            switchModeBtn.textContent = newMode === 'points' ? 'Point Mode' : 'Surface Mode';
            
            // Update control visibility
            updateControlVisibility(newMode);
            
            // Update text output
            updateTextOutput(`Switched to ${newMode} display mode`);
            
            console.log(`Successfully switched to ${newMode} mode`);
        } else {
            console.log('Mode switch failed');
            updateTextOutput('Mode switch failed - please try again');
        }
    });

    // Next segment button (Ctrl+Shift+Up)
    nextSegmentBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        moveToNextSegment();
        updateTextOutput('Moving to next segment...');
        setTimeout(() => {
            const navInfo = getCurrentNavigationInfo();
            if (navInfo) {
                updateTextOutput(navInfo);
            }
        }, 100);
    });

    // Previous segment button (Ctrl+Shift+Down)
    prevSegmentBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        moveToPrevSegment();
        updateTextOutput('Moving to previous segment...');
        setTimeout(() => {
            const navInfo = getCurrentNavigationInfo();
            if (navInfo) {
                updateTextOutput(navInfo);
            }
        }, 100);
    });

    // Listen for navigation updates from the actual DIXTRAL app
    document.addEventListener('navigation-info-updated', (event) => {
        if (event.detail && event.detail.message) {
            updateTextOutput(`Live: ${event.detail.message}`);
        }
    });

    // Listen for point highlighting changes
    document.addEventListener('point-highlighted', (event) => {
        if (event.detail) {
            const navInfo = getCurrentNavigationInfo();
            if (navInfo) {
                updateTextOutput(navInfo);
            }
            
            // Determine which mapping to highlight based on current navigation axis
            if (demoApp.navigation) {
                const currentAxis = demoApp.navigation.currentNavigationAxis;
                if (currentAxis === 'Y') highlightMapping('y');
                else if (currentAxis === 'Z') highlightMapping('z');
                else if (currentAxis === 'X') highlightMapping('x');
            }
        }
    });

    // Listen for autoplay state changes
    document.addEventListener('autoplay-state-changed', (event) => {
        if (event.detail && autoplayBtn) {
            const { active, mode } = event.detail;
            if (active) {
                autoplayBtn.textContent = 'Stop Autoplay (P)';
                autoplayBtn.classList.add('accent-bg', 'text-white');
                updateTextOutput(`Autoplay started in ${mode} mode`);
                highlightMapping('z');
            } else {
                autoplayBtn.textContent = 'Autoplay (P)';
                autoplayBtn.classList.remove('accent-bg', 'text-white');
                updateTextOutput('Autoplay stopped');
            }
        }
    });

    // Listen for sonification state changes
    document.addEventListener('sonification-toggled', (event) => {
        if (event.detail !== undefined && sonificationBtn) {
            if (event.detail.enabled) {
                sonificationBtn.classList.add('accent-bg', 'text-white');
                updateTextOutput('Audio sonification enabled');
            } else {
                sonificationBtn.classList.remove('accent-bg', 'text-white');
                updateTextOutput('Audio sonification disabled');
            }
        }
    });

    // Listen for navigation axis changes
    document.addEventListener('navigation-axis-changed', (event) => {
        if (event.detail && event.detail.axis) {
            updateTextOutput(`Navigation axis changed to: ${event.detail.axis}-axis mode`);
        }
    });

            // Focus the canvas to enable navigation after initialization
            setTimeout(() => {
                canvas?.focus();
                
                // Initialize display mode tracking
                currentDisplayMode = 'points'; // Ensure we start in points mode
                
                // Initialize control visibility (starts in point mode)
                updateControlVisibility('points');
                
                // Set initial button text
                if (switchModeBtn) {
                    switchModeBtn.textContent = 'Point Mode';
                }
                
                // Set up resize observer to handle canvas resizing
                if (canvas && demoApp.engine) {
                    const resizeObserver = new ResizeObserver(entries => {
                        for (let entry of entries) {
                            const { width, height } = entry.contentRect;
                            canvas.width = width;
                            canvas.height = height;
                            
                            // Update WebGL viewport
                            const gl = canvas.getContext('webgl');
                            if (gl) {
                                gl.viewport(0, 0, width, height);
                            }
                            
                            // Re-render
                            if (demoApp.engine && demoApp.data) {
                                demoApp.engine.render(demoApp.data);
                            }
                        }
                    });
                    resizeObserver.observe(canvas);
                }
            }, 1000);

    // --- Architecture Layer Logic (keep existing) ---
    const layerBtns = document.querySelectorAll('.layer-btn');
    const layerTitle = document.getElementById('layer-title');
    const layerDesc = document.getElementById('layer-desc');

    const layerInfo = {
        app: {
            title: 'Application Layer',
            desc: 'This top-level layer manages the application\'s lifecycle, initializes all other system components in the correct order, and handles global event coordination and error handling.'
        },
        ui: {
            title: 'UI Layer',
            desc: 'Responsible for all user-facing interface components, including controls, menus, and visual themes. It handles all visual updates and coordinates the display of plot types and axes.'
        },
        access: {
            title: 'Accessibility Layer',
            desc: 'The core of DIXTRAL\'s mission. This layer centralizes all non-visual functionalities like sonification, text-to-speech, gamepad input, and the tri-axis navigation system. It operates independently of the rendering engine.'
        },
        engine: {
            title: 'Engine Layer',
            desc: 'Contains the custom WebGL-based rendering pipeline. It manages all visualization tasks, including real-time rendering of point clouds and surface meshes, shader management, and performance optimization.'
        },
        data: {
            title: 'Data Layer',
            desc: 'Manages all data-related operations. It handles data ingestion from various formats (CSV, JSON), validation, normalization, and computes descriptive statistics for display.'
        }
    };

    layerBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            layerBtns.forEach(b => b.classList.remove('accent-border', 'bg-teal-50'));
            btn.classList.add('accent-border', 'bg-teal-50');

            const layerId = btn.id.split('-')[1];
            if (layerInfo[layerId]) {
                layerTitle.textContent = layerInfo[layerId].title;
                layerDesc.textContent = layerInfo[layerId].desc;
            }
        });
    });
});
</script>

</body>
</html>
